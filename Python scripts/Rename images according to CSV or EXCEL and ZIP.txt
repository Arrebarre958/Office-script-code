import os
import pandas as pd
import uuid
import zipfile
import re

def natural_key(string_):
    """Helper function for natural (human) sorting of filenames."""
    return [int(text) if text.isdigit() else text.lower() for text in re.split('([0-9]+)', string_)]

def rename_images(folder_path, data_file):
    # Determine file type (CSV or Excel) and read accordingly
    file_ext = os.path.splitext(data_file)[-1].lower()
    if file_ext == ".csv":
        df = pd.read_csv(data_file, header=None)
    elif file_ext in (".xls", ".xlsx"):
        df = pd.read_excel(data_file, header=None)
    else:
        print("Unsupported file format. Please provide a CSV or Excel file.")
        return

    # Ensure the folder path exists
    if not os.path.exists(folder_path):
        print(f"The folder path {folder_path} does not exist.")
        return

    # Get the list of image files in the folder
    image_files = [f for f in os.listdir(folder_path) if os.path.isfile(os.path.join(folder_path, f))]
    
    # Use natural sort to order files as humans expect (e.g., image2.jpg comes before image10.jpg)
    image_files.sort(key=natural_key)

    # Temporarily rename all images to avoid conflicts, preserving original file extensions
    temp_names = []
    for image_file in image_files:
        _, original_ext = os.path.splitext(image_file)
        temp_name = f"temp_{uuid.uuid4().hex}{original_ext}"
        temp_file_path = os.path.join(folder_path, temp_name)
        old_file_path = os.path.join(folder_path, image_file)
        os.rename(old_file_path, temp_file_path)
        temp_names.append(temp_file_path)
        print(f"Temporarily renamed '{image_file}' to '{temp_name}'")

    # Rename the images to their final names based on the CSV/Excel data
    for i, temp_file_path in enumerate(temp_names):
        if i >= len(df):
            break  # if there are more images than rows, stop processing
        new_name = str(df.iloc[i, 0])  # Convert to string in case it's numeric
        _, ext = os.path.splitext(temp_file_path)
        new_file_path = os.path.join(folder_path, f"{new_name}{ext}")

        # Add a unique suffix if the file already exists
        unique_file_path = new_file_path
        counter = 1
        while os.path.exists(unique_file_path):
            unique_file_path = os.path.join(folder_path, f"{new_name}_{counter}{ext}")
            counter += 1

        os.rename(temp_file_path, unique_file_path)
        print(f"Renamed '{temp_file_path}' to '{unique_file_path}'")

def create_zip_archives(folder_path, images_per_zip=10):
    # Define the image file extensions to consider
    image_extensions = ('.png', '.jpg', '.jpeg', '.bmp', '.gif')
    
    # List only the image files (ignoring other file types)
    image_files = [f for f in os.listdir(folder_path)
                   if f.lower().endswith(image_extensions) and os.path.isfile(os.path.join(folder_path, f))]
    # Use natural sort to order the files consistently
    image_files.sort(key=natural_key)
    
    total_images = len(image_files)
    print(f"Total images found for zipping: {total_images}")

    zip_count = 0
    # Group the images into batches
    for i in range(0, total_images, images_per_zip):
        zip_count += 1
        group = image_files[i:i + images_per_zip]
        zip_filename = os.path.join(folder_path, f"{zip_count}.zip")
        with zipfile.ZipFile(zip_filename, 'w', zipfile.ZIP_DEFLATED) as zipf:
            for image in group:
                image_path = os.path.join(folder_path, image)
                # Store file without full path in the ZIP
                zipf.write(image_path, arcname=image)
        print(f"Created ZIP archive '{zip_filename}' containing {len(group)} images.")

# Example usage:
folder_path = r"C:\Users\aron.erici\Desktop\Helmets"  # Adjust your folder path
data_file = r"C:\Users\aron.erici\Desktop\all LB helmets done.csv"  # Supports both CSV and Excel

# First, rename the images based on your CSV/Excel data
rename_images(folder_path, data_file)

# Then, create ZIP files with 10 images each.
create_zip_archives(folder_path, images_per_zip=10)
